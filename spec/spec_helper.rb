# frozen_string_literal: true

require 'sidekiq/testing'
require 'simplecov'
require 'vcr'
require 'webmock/rspec'
SimpleCov.start 'rails' do
  enable_coverage :branch
end

# This file was generated by the `rails generate rspec:install` command. Conventionally, all
# specs live under a `spec` directory, which RSpec adds to the `$LOAD_PATH`.
# The generated `.rspec` file contains `--require spec_helper` which will cause
# this file to always be loaded, without a need to explicitly require it in any
# files.
#
# See https://rubydoc.info/gems/rspec-core/RSpec/Core/Configuration
RSpec.configure do |config|
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups

  VCR.configure do |c|
    c.cassette_library_dir = 'vcr_cassettes'
    c.hook_into :webmock
    c.allow_http_connections_when_no_cassette = false
    c.configure_rspec_metadata!
    c.default_cassette_options = { decode_compressed_response: true }

    c.ignore_request do |request|
      request.uri == 'https://accounts.spotify.com/api/token'
    end

    c.filter_sensitive_data('<BEARER ACCESS TOKEN>') do |interaction|
      interaction.request.headers['Authorization'].first
    end
  end

  RSpec::Matchers.define_negated_matcher :avoid_changing, :change
  RSpec::Matchers.define_negated_matcher :exclude, :include

  def generate_spotify_id
    length_of_spotify_id = 22
    charset = Array('A'..'Z') + Array('a'..'z') + Array(0..9)

    Array.new(length_of_spotify_id) { charset.sample }.join
  end

  config.around(:each, type: :job) do |test|
    Sidekiq::Testing.inline! do
      test.run
    end
  end

  RSpec.shared_context 'with a stubbed retryable error' do
    let(:exception) { Struct.new(:headers).new({ retry_after: '1' }) }
    let(:error) { error_class.new(exception) }
    let(:error_class) { raise 'Must set an error_class to use this shared context' }
    let(:recipient) { raise 'Must set an recipient to use this shared context' }
    let(:message) { raise 'Must set an message to use thisshared context' }

    before do
      call_count = 0
      method = recipient.method(message)

      allow(recipient).to receive(message) do |args|
        call_count += 1
        call_count == 1 ? raise(error) : call_original_method(method, args)
      end
    end

    def call_original_method(method, args)
      return method.call if args.blank?

      if args.is_a?(Hash)
        method.call(**args)
      else
        method.call(args)
      end
    end
  end

  RSpec.shared_context 'with Tracks with Artists and Genres' do
    let(:track_with_genres) do
      create(
        :track,
        name: 'Track with Genres',
        spotify_id: generate_spotify_id,
        artists: [
          create(:artist, spotify_id: generate_spotify_id, genres: [genre_a, genre_b]),
          create(:artist, spotify_id: generate_spotify_id, genres: [genre_a])
        ]
      )
    end
    let(:nil_genre_track) do
      create(
        :track,
        name: 'Track with no Genres',
        spotify_id: generate_spotify_id,
        artists: [create(:artist, spotify_id: generate_spotify_id)]
      )
    end
    let(:genre_a) { create(:genre, name: genre_name_matches_all_artists) }
    let(:genre_b) { create(:genre, name: genre_name_matches_some_artists) }
    let(:genre_name_matches_all_artists) { 'A' }
    let(:genre_name_matches_some_artists) { 'B' }
    let(:genre_name_matches_no_artists) { 'C' }
  end

  # The settings below are suggested to provide a good initial experience
  # with RSpec, but feel free to customize to your heart's content.
  #   # This allows you to limit a spec run to individual examples or groups
  #   # you care about by tagging them with `:focus` metadata. When nothing
  #   # is tagged with `:focus`, all examples get run. RSpec also provides
  #   # aliases for `it`, `describe`, and `context` that include `:focus`
  #   # metadata: `fit`, `fdescribe` and `fcontext`, respectively.
  #   config.filter_run_when_matching :focus
  #
  #   # Allows RSpec to persist some state between runs in order to support
  #   # the `--only-failures` and `--next-failure` CLI options. We recommend
  #   # you configure your source control system to ignore this file.
  #   config.example_status_persistence_file_path = "spec/examples.txt"
  #
  #   # Limits the available syntax to the non-monkey patched syntax that is
  #   # recommended. For more details, see:
  #   # https://relishapp.com/rspec/rspec-core/docs/configuration/zero-monkey-patching-mode
  #   config.disable_monkey_patching!
  #
  #   # Many RSpec users commonly either run the entire suite or an individual
  #   # file, and it's useful to allow more verbose output when running an
  #   # individual spec file.
  #   if config.files_to_run.one?
  #     # Use the documentation formatter for detailed output,
  #     # unless a formatter has already been configured
  #     # (e.g. via a command-line flag).
  #     config.default_formatter = "doc"
  #   end
  #
  #   # Print the 10 slowest examples and example groups at the
  #   # end of the spec run, to help surface which specs are running
  #   # particularly slow.
  #   config.profile_examples = 10
  #
  #   # Run specs in random order to surface order dependencies. If you find an
  #   # order dependency and want to debug it, you can fix the order by providing
  #   # the seed, which is printed after each run.
  #   #     --seed 1234
  #   config.order = :random
  #
  #   # Seed global randomization in this process using the `--seed` CLI option.
  #   # Setting this allows you to use `--seed` to deterministically reproduce
  #   # test failures related to randomization by passing the same `--seed` value
  #   # as the one that triggered the failure.
  #   Kernel.srand config.seed
end
